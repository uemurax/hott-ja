<!DOCTYPE html>
<html><head prefix="og: https://ogp.me/ns#"><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width,initial-scale=1"></meta><title>同一視型 -- ホモトピー型理論</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous"></link><meta property="og:title" content="同一視型"></meta><meta property="og:site_name" content="ホモトピー型理論"></meta><meta property="og:type" content="article"></meta><meta property="og:url" content="https://uemurax.github.io/000C.html"></meta><meta name="description" content="ホモトピー型理論についての文書"></meta><meta property="og:description" content="ホモトピー型理論についての文書"></meta><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded", function() {
  const elems = document.getElementsByClassName('morg-generated-katex');
  for(let i = 0; i < elems.length; i++) {
    renderMathInElement(elems[i], {
      delimiters: [
        {left: '\\(',
         right: '\\)',
         display: false}
      ]
    });
  }
});</script><link rel="stylesheet" href="default.css"></link><link rel="stylesheet" href="custom.css"></link></head><body><div id="morg-generated-default-body-container"><div id="morg-generated-default-header"><button id="morg-generated-default-side-button" onclick="morg_generated_default_toggle_side_nav();">☰</button><script>function morg_generated_default_toggle_side_nav() {
  console.log('called.');
  let e = document.getElementById('morg-generated-default-side-nav');
  console.log(e);
  if (e.style.display == "none") {
    e.style.display = "block";
  }
  else {
    e.style.display = "none";
  }
}</script><a class="morg-generated-default-site-title" href="index.html">ホモトピー型理論</a></div><nav id="morg-generated-default-side-nav" style="display: none;"><ol class="morg-generated-document-toc"><li class="morg-generated-document-front-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007H.html">貢献者</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li><li class="morg-generated-document-main-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0000.html">はじめに</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0077.html">型理論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0076.html">統一された正しい同一視の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0078.html">一価性公理とホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000R.html">識別子</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details" open="true"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0001.html">型理論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0009.html">宇宙</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000A.html">関数型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000B.html">レコード型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary-selected"><a class="morg-generated-toc-edge-title" href="000C.html">同一視型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002N.html">高次グルーポイド構造</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002T.html">自然数</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002U.html">有限余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0002.html">一価性公理</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000S.html">可縮性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001R.html">同一視型の基本定理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000X.html">一価性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001Y.html">関数外延性</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0021.html">一価性から関数外延性を導く</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0022.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000U.html">同値</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004I.html">他の同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003W.html"><span class="morg-generated-katex">\(n\)</span>型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003Z.html">命題</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004N.html">同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004B.html">集合</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004Z.html">切り詰め</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0057.html">述語論理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005T.html">連結性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004V.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0003.html">高次帰納的型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0033.html">ファイバー余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0034.html">降下性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007Y.html">局所化</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0005.html">ホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0004.html">圏論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005B.html">圏</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005J.html">関手</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0065.html">自然変換</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="006D.html">前層</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></div></li><li class="morg-generated-document-back-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007E.html">参考文献</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007X.html">記法の一覧</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007F.html">索引</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li></ol></nav><div id="morg-generated-default-main-container"><div class="morg-generated-default-main-container"><nav><ol class="morg-generated-breadcrumb"><li class="morg-generated-breadcumrb-top"><a class="morg-generated-id" href="index.html">[index]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="0001.html">[0001]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="000C.html">[000C]</a></li></ol></nav><main><section class="morg-generated-section"><h1 class="morg-generated-section-title"><a class="morg-generated-id" href="000C.html">[000C]</a> 同一視型</h1><div class="morg-generated-section-body"><p class="morg-generated-paragraph"><em class="morg-generated-emph">同一視型</em>はホモトピー型理論において最も特徴的な型である。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="000P.html">[000P]</a> <span class="morg-generated-statement-header-header">規則</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(a_{1}:A\)</span>を要素とする。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(a_{2}:A\)</span>に対し、<dfn class="morg-generated-dfn">同一視型(identity type)</dfn><span class="morg-generated-katex">\(a_{1}=a_{2}:\mathcal {U}(i)\)</span>を構成できる。<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>の要素を<span class="morg-generated-katex">\(a_{1}\)</span>と<span class="morg-generated-katex">\(a_{2}\)</span>の<dfn class="morg-generated-dfn">同一視(identification)</dfn>と呼ぶ。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\lbrace a_{1}\rbrace :a_{1}=a_{1}\)</span>を構成できる。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(a_{2}:A\)</span>と<span class="morg-generated-katex">\(p:a_{1}=a_{2}\)</span>を要素、<span class="morg-generated-katex">\(j\)</span>を階数、<span class="morg-generated-katex">\(B:\prod _{\lbrace x:A\rbrace }a_{1}=x\to \mathcal {U}(j)\)</span>を型の族、<span class="morg-generated-katex">\(b:B(\mathord {\textnormal {\textsf {refl}}})\)</span>を要素とすると、要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{=}(p,B,b):B(p)\)</span>を構成できる。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(j\)</span>を階数、<span class="morg-generated-katex">\(B:\prod _{\lbrace x:A\rbrace }a_{1}=x\to \mathcal {U}(j)\)</span>を型の族、<span class="morg-generated-katex">\(b:B(\mathord {\textnormal {\textsf {refl}}})\)</span>を要素とすると、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{=}(\mathord {\textnormal {\textsf {refl}}},B,b)\equiv b\)</span>と定義される。</li></ul></p></div></div></article><p class="morg-generated-paragraph"><a class="morg-generated-id" href="HoTT-Book.html">[HoTT-Book]</a>にならって同一視型に等号の記号を使うが、その意味は従来の数学の等号とは大きく異なる。従来の数学では、<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>といえば<span class="morg-generated-katex">\(a_{1}\)</span>と<span class="morg-generated-katex">\(a_{2}\)</span>が等しいという命題であるが、型理論では<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>はあくまで型である。従って、<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>の要素というものを考えることができ、それは非形式的には<span class="morg-generated-katex">\(a_{1}\)</span>と<span class="morg-generated-katex">\(a_{2}\)</span>の同一視のしかたと解釈される。</p><p class="morg-generated-paragraph"><a class="morg-generated-id" href="000P.html">[000P]</a>について説明する。<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}:a_{1}=a_{1}\)</span>は<span class="morg-generated-katex">\(a_{1}\)</span>とそれ自身の自明な同一視を表す。残りの規則はいわゆる<em class="morg-generated-emph">帰納法原理</em>の一例で、任意の<span class="morg-generated-katex">\(a_{2}:A\)</span>と同一視型の要素<span class="morg-generated-katex">\(p:a_{1}=a_{2}\)</span>を使ってなんらかを構成するためには<span class="morg-generated-katex">\(p\)</span>が<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\)</span>の場合の構成(<span class="morg-generated-katex">\(b:B(\mathord {\textnormal {\textsf {refl}}})\)</span>)を与えれば十分であると読める。注意するべきこととして、この帰納法原理から<span class="morg-generated-katex">\(a_{1}=a_{1}\)</span>の要素は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\)</span>しか無いことは<em class="morg-generated-emph">導出されない</em>。同一視型の規則の正しい読み方は型の族<span class="morg-generated-katex">\(\lambda x.(a_{1}=x):A\to \mathcal {U}(i)\)</span>が<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}:a_{1}=a_{1}\)</span>で自由に生成されることであって、個々の型<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>については特に言えることはない。</p><p class="morg-generated-paragraph">同一視型からの関数を定義するには<em class="morg-generated-emph">パターンマッチ</em>が便利である。パターンマッチは一般に帰納的型からの関数を構成子による場合分けで定義する手法である。同一視型の構成子は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\)</span>だけなのでその場合の定義だけを与えれば関数を定義できることになる。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="008D.html">[008D]</a> <span class="morg-generated-statement-header-header">記法</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{=}\)</span>を使って関数を定義するには次のいずれかのような言い回しをする。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>関数<span class="morg-generated-katex">\(f:\prod _{\lbrace x:A\rbrace }\prod _{p:a_{1}=x}B(p)\)</span>を<span class="morg-generated-katex">\(\lambda (x,p).\mathord {\textnormal {\textsf {ind}}}_{=}(p,B,b)\)</span>と定義する。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>関数<span class="morg-generated-katex">\(f:\prod _{\lbrace x:A\rbrace }\prod _{p:a_{1}=x}B(p)\)</span>を<span class="morg-generated-katex">\(f(\mathord {\textnormal {\textsf {refl}}})\equiv b\)</span>で定義する。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(x:A\)</span>を要素、<span class="morg-generated-katex">\(p:a_{1}=x\)</span>を同一視とする。要素<span class="morg-generated-katex">\(f(p):B(p)\)</span>を<span class="morg-generated-katex">\(f(\mathord {\textnormal {\textsf {refl}}})\equiv b\)</span>で定義する。</li></ul></p></div></div></article><p class="morg-generated-paragraph">パターンマッチが有効なのはもちろん<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{=}\)</span>を使ったものに書き直せる時だけである。例えば、「関数<span class="morg-generated-katex">\(f:a=a\to B\)</span>を<span class="morg-generated-katex">\(f(\mathord {\textnormal {\textsf {refl}}})\equiv b\)</span>と定義する」という使い方はできない。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>が同一視型と呼ぶに価することを確認するために、いくつかの期待される関数を構成しよう。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001C.html">[001C]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(j\)</span>を階数、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(j)\)</span>を型の族とする。<span class="morg-generated-katex">\(a_{1},a_{2}:A\)</span>と<span class="morg-generated-katex">\(p:a_{1}=a_{2}\)</span>を要素とする。<dfn class="morg-generated-dfn">輸送関数(transport function)</dfn><center class="morg-generated-display"><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {transport}}}(B,p):B(a_{1})\to B(a_{2})\)</span></center>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {transport}}}(B,\mathord {\textnormal {\textsf {refl}}})\equiv \mathord {\textnormal {\textsf {id}}}\)</span>で定義する。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001G.html">[001G]</a> <span class="morg-generated-statement-header-header">比較</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">述語論理において、<span class="morg-generated-katex">\(B\)</span>を一変数の述語とすると、<span class="morg-generated-katex">\(x_{1}=x_{2}\to B(x_{1})\to B(x_{2})\)</span>が成り立つ。これは等しい対象は述語によって区別できないことを表す。<a class="morg-generated-id" href="001C.html">[001C]</a>はこの類似で、型理論においては同一視される要素を型の族では区別できないことを表す。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001D.html">[001D]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(a_{0},a_{1},a_{2}:A\)</span>を要素、<span class="morg-generated-katex">\(p_{1}:a_{0}=a_{1}\)</span>と<span class="morg-generated-katex">\(p_{2}:a_{0}=a_{2}\)</span>を同一視とする。同一視<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ext}}}(p_{1},p_{2}):a_{1}=a_{2}\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {transport}}}(\lambda x.(x=a_{2}),p_{1},p_{2})\)</span>と定義する。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001E.html">[001E]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型とする。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>関数<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {sym}}}:\prod _{\lbrace x_{1},x_{2}:A\rbrace }x_{1}=x_{2}\to x_{2}=x_{1}\)</span>を<span class="morg-generated-katex">\(\lambda (x_{1},x_{2},z).\mathord {\textnormal {\textsf {ext}}}(z,\mathord {\textnormal {\textsf {refl}}})\)</span>と定義する。<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {sym}}}(p)\)</span>を<span class="morg-generated-katex">\({p}^{-1}\)</span>とも書く。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>関数<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {trans}}}:\prod _{\lbrace x_{1},x_{2},x_{3}:A\rbrace }x_{1}=x_{2}\to x_{2}=x_{3}\to x_{1}=x_{3}\)</span>を<span class="morg-generated-katex">\(\lambda (x_{1},x_{2},x_{3},z,w).\mathord {\textnormal {\textsf {ext}}}({z}^{-1},w)\)</span>と定義する。<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {trans}}}(p,q)\)</span>を<span class="morg-generated-katex">\(q\circ p\)</span>とも書く。</li></ul></p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001H.html">[001H]</a> <span class="morg-generated-statement-header-header">比較</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">述語論理において、<em class="morg-generated-emph">対称律</em><span class="morg-generated-katex">\(x_{1}=x_{2}\to x_{2}=x_{1}\)</span>と<em class="morg-generated-emph">推移律</em><span class="morg-generated-katex">\(x_{1}=x_{2}\to x_{2}=x_{3}\to x_{1}=x_{3}\)</span>が成り立つ。<a class="morg-generated-id" href="001E.html">[001E]</a>はこの類似である。ちなみに、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}:x=x\)</span>は<em class="morg-generated-emph">反射律</em>とも思える。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001F.html">[001F]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(f:A\to B\)</span>を関数とする。関数<center class="morg-generated-display"><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ap}}}(f):\prod _{\lbrace x_{1},x_{2}:A\rbrace }x_{1}=x_{2}\to f(x_{1})=f(x_{2})\)</span></center>を<span class="morg-generated-katex">\(\lambda (x_{1},x_{2},z).\mathord {\textnormal {\textsf {transport}}}(\lambda x.(f(x_{1})=f(x)),z,\mathord {\textnormal {\textsf {refl}}})\)</span>と定義する。文脈上わかる場合は、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ap}}}(f,p)\)</span>のことを<span class="morg-generated-katex">\(f(p)\)</span>と書いてしまうこともある。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001I.html">[001I]</a> <span class="morg-generated-statement-header-header">比較</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">述語論理において、<span class="morg-generated-katex">\(f\)</span>を一変数の関数とすると、<span class="morg-generated-katex">\(x_{1}=x_{2}\to f(x_{1})=f(x_{2})\)</span>が成り立つ。これは関数が等しさを保つことを表す。<a class="morg-generated-id" href="001F.html">[001F]</a>はこの類似で、型理論において関数は同一視を保つことを表す。</p></div></div></article></div><nav class="morg-generated-section-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002N.html">高次グルーポイド構造</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></nav></section></main><nav><ol class="morg-generated-d-pad"><li class="morg-generated-d-pad-previous"><a href="000B.html">←</a></li><li class="morg-generated-d-pad-up"><a href="0001.html">↑</a></li><li class="morg-generated-d-pad-next"><a href="002T.html">→</a></li></ol></nav></div></div></div></body></html>