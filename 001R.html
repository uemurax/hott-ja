<!DOCTYPE html>
<html><head prefix="og: https://ogp.me/ns#"><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width,initial-scale=1"></meta><title>同一視型の基本定理 -- ホモトピー型理論</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous"></link><meta property="og:title" content="同一視型の基本定理"></meta><meta property="og:site_name" content="ホモトピー型理論"></meta><meta property="og:type" content="article"></meta><meta property="og:url" content="https://uemurax.github.io/001R.html"></meta><meta name="description" content="ホモトピー型理論についての文書"></meta><meta property="og:description" content="ホモトピー型理論についての文書"></meta><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded", function() {
  const elems = document.getElementsByClassName('morg-generated-katex');
  for(let i = 0; i < elems.length; i++) {
    renderMathInElement(elems[i], {
      delimiters: [
        {left: '\\(',
         right: '\\)',
         display: false}
      ]
    });
  }
});</script><link rel="stylesheet" href="default.css"></link><link rel="stylesheet" href="custom.css"></link></head><body><div id="morg-generated-default-body-container"><div id="morg-generated-default-header"><button id="morg-generated-default-side-button" onclick="morg_generated_default_toggle_side_nav();">☰</button><script>function morg_generated_default_toggle_side_nav() {
  console.log('called.');
  let e = document.getElementById('morg-generated-default-side-nav');
  console.log(e);
  if (e.style.display == "none") {
    e.style.display = "block";
  }
  else {
    e.style.display = "none";
  }
}</script><a class="morg-generated-default-site-title" href="index.html">ホモトピー型理論</a></div><nav id="morg-generated-default-side-nav" style="display: none;"><ol class="morg-generated-document-toc"><li class="morg-generated-document-front-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007H.html">貢献者</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li><li class="morg-generated-document-main-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0000.html">はじめに</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0077.html">型理論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0076.html">統一された正しい同一視の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0078.html">一価性公理とホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000R.html">識別子</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0001.html">型理論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0009.html">宇宙</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000A.html">関数型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000B.html">レコード型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000C.html">同一視型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002N.html">高次グルーポイド構造</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002T.html">自然数</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002U.html">有限余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details" open="true"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0002.html">一価性公理</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000S.html">可縮性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary-selected"><a class="morg-generated-toc-edge-title" href="001R.html">同一視型の基本定理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000X.html">一価性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001Y.html">関数外延性</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0021.html">一価性から関数外延性を導く</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0022.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000U.html">同値</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004I.html">他の同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003W.html"><span class="morg-generated-katex">\(n\)</span>型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003Z.html">命題</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004N.html">同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004B.html">集合</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004Z.html">切り詰め</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0057.html">述語論理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005T.html">連結性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004V.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0003.html">高次帰納的型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0033.html">ファイバー余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0034.html">降下性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007Y.html">局所化</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0005.html">ホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0004.html">圏論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005B.html">圏</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005J.html">関手</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0065.html">自然変換</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="006D.html">前層</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></div></li><li class="morg-generated-document-back-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007E.html">参考文献</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007X.html">記法の一覧</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007F.html">索引</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li></ol></nav><div id="morg-generated-default-main-container"><div class="morg-generated-default-main-container"><nav><ol class="morg-generated-breadcrumb"><li class="morg-generated-breadcumrb-top"><a class="morg-generated-id" href="index.html">[index]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="0002.html">[0002]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="001R.html">[001R]</a></li></ol></nav><main><section class="morg-generated-section"><h1 class="morg-generated-section-title"><a class="morg-generated-id" href="001R.html">[001R]</a> 同一視型の基本定理</h1><div class="morg-generated-section-body"><p class="morg-generated-paragraph">同一視型はすべての型に対して一様に定義されているが、個々の型については具体的な同一視のしかたが期待される。例えば、対型の要素<span class="morg-generated-katex">\(c_{1},c_{2}:A\times B\)</span>の「自然な」同一視のしかたは<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})\)</span>を同一視しかつ<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2})\)</span>を同一視することである。つまり、同値<span class="morg-generated-katex">\((c_{1}=c_{2})\simeq (\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2}))\times (\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\)</span>を構成できると期待される(<a class="morg-generated-id" href="002D.html">[002D]</a>)。<em class="morg-generated-emph">同一視型の基本定理</em>(<a class="morg-generated-id" href="001S.html">[001S]</a>)は、この手の同値を構成する手順を与える。</p><p class="morg-generated-paragraph">型<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>に興味があるとして、要素<span class="morg-generated-katex">\(a:A\)</span>に対して同一視型の族<span class="morg-generated-katex">\(\lambda x.(a=x):A\to \mathcal {U}(i)\)</span>を特徴付けることを考える。具体的に特徴付けの候補<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を見つけたとしよう。これが正しいものなら、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\)</span>に対応する要素<span class="morg-generated-katex">\(b:B(a)\)</span>があるはずである。同一視型の帰納法により、<span class="morg-generated-katex">\(b\)</span>は関数<span class="morg-generated-katex">\(b':\prod _{x:A}a=x\to B(x)\)</span>に拡張される。<span class="morg-generated-katex">\(b'(x):a=x\to B(x)\)</span>は「標準的」な比較関数であり、これが同値であることを示したい。<span class="morg-generated-katex">\(b'(x)\)</span>の同値性を定義に従って示すことは難しくはないが筋が良いとも言えない。同一視型の基本定理は、すべての<span class="morg-generated-katex">\(b'(x)\)</span>が同値であることと<span class="morg-generated-katex">\(\sum _{x:A}B(x)\)</span>が可縮であることが論理的に同値であると主張する。次の点から後者の方が示しやすい性質であると思われる。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>可縮性は様々な型の構成について閉じる(例えば<a class="morg-generated-id" href="001L.html">[001L]</a>や<a class="morg-generated-id" href="001N.html">[001N]</a>)。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(\sum _{x:A}B(x)\)</span>の可縮性は<span class="morg-generated-katex">\(a\)</span>や<span class="morg-generated-katex">\(b\)</span>や<span class="morg-generated-katex">\(b'\)</span>に依らない性質である。</li></ul></p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001V.html">[001V]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(e:A\simeq B\)</span>を同値とすると、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Retract}}}(B,A)\)</span>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph">仮定<span class="morg-generated-katex">\(e\)</span>から<span class="morg-generated-katex">\(f:A\to B\)</span>と<span class="morg-generated-katex">\(H:\mathord {\textnormal {\textsf {IsEquiv}}}(f)\)</span>を得る。任意の<span class="morg-generated-katex">\(y:B\)</span>に対して<span class="morg-generated-katex">\(H(y):\mathord {\textnormal {\textsf {IsContr}}}(\mathord {\textnormal {\textsf {Fiber}}}(f,y))\)</span>を得るので、特に関数<span class="morg-generated-katex">\(G:\prod _{y:B}\mathord {\textnormal {\textsf {Fiber}}}(f,y)\)</span>を得る。<a class="morg-generated-id" href="001A.html">[001A]</a>の要領で<span class="morg-generated-katex">\(G\)</span>から関数<span class="morg-generated-katex">\(g:B\to A\)</span>と同一視<span class="morg-generated-katex">\(p:\prod _{y:B}f(g(y))=y\)</span>を得る。これで要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {record}}}\mathopen {\{ \negmedspace |}\mathord {\textnormal {\textsf {retraction}}}\equiv f,\mathord {\textnormal {\textsf {section}}}\equiv g,\mathord {\textnormal {\textsf {r-s}}}\equiv p\mathclose {|\negmedspace \} }:\mathord {\textnormal {\textsf {Retract}}}(B,A)\)</span>を構成できた。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001X.html">[001X]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(c_{1},c_{2}:\sum _{x:A}B(x)\)</span>を要素とすると、<center class="morg-generated-display"><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Retract}}}(\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}),c_{1}=c_{2})\)</span></center>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph">関数<span class="morg-generated-katex">\(f:(\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\to c_{1}=c_{2}\)</span>と<span class="morg-generated-katex">\(g:c_{1}=c_{2}\to (\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\)</span>と同一視<span class="morg-generated-katex">\(p:\prod _{w}g(f(w))=w\)</span>を構成する。<span class="morg-generated-katex">\(f\)</span>についてはカリー化、一般化して<center class="morg-generated-display"><span class="morg-generated-katex">\(f':\prod _{\lbrace x:A\rbrace }\prod _{\lbrace y:B(x)\rbrace }\prod _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=x}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=y\to c_{1}=\mathord {\textnormal {\textsf {pair}}}(x,y)\)</span></center>を構成すればよいが、同一視型の帰納法により<span class="morg-generated-katex">\(f'(\mathord {\textnormal {\textsf {refl}}},\mathord {\textnormal {\textsf {refl}}})\equiv \mathord {\textnormal {\textsf {refl}}}\)</span>と定義できる。<span class="morg-generated-katex">\(g\)</span>は一般化して<center class="morg-generated-display"><span class="morg-generated-katex">\(g':\prod _{\lbrace y:\sum _{x:A}B(x)\rbrace }c_{1}=y\to (\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(y)}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(y))\)</span></center>を帰納法で<span class="morg-generated-katex">\(g'(\mathord {\textnormal {\textsf {refl}}})\equiv \mathord {\textnormal {\textsf {pair}}}(\mathord {\textnormal {\textsf {refl}}},\mathord {\textnormal {\textsf {refl}}})\)</span>と定義する。<span class="morg-generated-katex">\(p\)</span>も<span class="morg-generated-katex">\(f\)</span>と同様にカリー化、一般化して<center class="morg-generated-display"><span class="morg-generated-katex">\(p':\prod _{\lbrace x\rbrace }\prod _{\lbrace y\rbrace }\prod _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=x}\prod _{w:\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=y}g'(f'(z,w))=\mathord {\textnormal {\textsf {pair}}}(z,w)\)</span></center>を帰納法により<span class="morg-generated-katex">\(p'(\mathord {\textnormal {\textsf {refl}}},\mathord {\textnormal {\textsf {refl}}})\equiv \mathord {\textnormal {\textsf {refl}}}\)</span>と定義する。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001W.html">[001W]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B,C:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(r:\prod _{x:A}\mathord {\textnormal {\textsf {Retract}}}(B(x),C(x))\)</span>を要素とすると、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Retract}}}(\sum _{x:A}B(x),\sum _{x:A}C(x))\)</span>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph">仮定<span class="morg-generated-katex">\(r\)</span>から関数<span class="morg-generated-katex">\(f:\prod _{\lbrace x:A\rbrace }B(x)\to C(x)\)</span>と<span class="morg-generated-katex">\(g:\prod _{\lbrace x:A\rbrace }C(x)\to B(x)\)</span>と同一視<span class="morg-generated-katex">\(p:\prod _{x:A}\prod _{y:B(x)}g(f(y))=y\)</span>を得る。関数<span class="morg-generated-katex">\(F:(\sum _{x:A}B(x))\to (\sum _{x:A}C(x))\)</span>を<span class="morg-generated-katex">\(\lambda z.\mathord {\textnormal {\textsf {pair}}}(\mathord {\textnormal {\textsf {proj}}}_{1}(z),f(\mathord {\textnormal {\textsf {proj}}}_{2}(z)))\)</span>と定義する。関数<span class="morg-generated-katex">\(G:(\sum _{x:A}C(x))\to (\sum _{x:A}B(x))\)</span>も同様に<span class="morg-generated-katex">\(g\)</span>を使って定義される。同一視<span class="morg-generated-katex">\(P:\prod _{z:\sum _{x:A}B(x)}G(F(z))=z\)</span>を定義するために、<span class="morg-generated-katex">\(z:\sum _{x:A}B(x)\)</span>を仮定する。構成から<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{1}(G(F(z)))\equiv \mathord {\textnormal {\textsf {proj}}}_{1}(z)\)</span>であり、<span class="morg-generated-katex">\(p(\mathord {\textnormal {\textsf {proj}}}_{1}(z),\mathord {\textnormal {\textsf {proj}}}_{2}(z)):\mathord {\textnormal {\textsf {proj}}}_{2}(G(F(z)))=\mathord {\textnormal {\textsf {proj}}}_{2}(z)\)</span>を得る。<a class="morg-generated-id" href="001X.html">[001X]</a>を使って、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {pair}}}(\mathord {\textnormal {\textsf {refl}}},p(\mathord {\textnormal {\textsf {proj}}}_{1}(z),\mathord {\textnormal {\textsf {proj}}}_{2}(z)))\)</span>から<span class="morg-generated-katex">\(G(F(z))=z\)</span>の要素を構成できる。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="001S.html">[001S]</a> <span class="morg-generated-statement-header-header">定理</span><span class="morg-generated-statement-header-title">(同一視型の基本定理)</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(a:A\)</span>を要素、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(b:B(a)\)</span>を要素とする。次の型は論理的に同値である。
<ol class="morg-generated-ordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井001S井0000">1</a></span><span class="morg-generated-katex">\(\prod _{x:A}\mathord {\textnormal {\textsf {IsEquiv}}}(\lambda (p:a=x).\mathord {\textnormal {\textsf {transport}}}(B,p,b))\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井001S井0001">2</a></span><span class="morg-generated-katex">\(\prod _{x:A}(a=x)\simeq B(x)\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井001S井0002">3</a></span><span class="morg-generated-katex">\(\prod _{x:A}\mathord {\textnormal {\textsf {Retract}}}(B(x),a=x)\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井001S井0003">4</a></span><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsContr}}}(\sum _{x:A}B(x))\)</span></li></ol></p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(\lambda (p:a=x).\mathord {\textnormal {\textsf {transport}}}(B,p,b)\)</span>の型が<span class="morg-generated-katex">\(a=x\to B(x)\)</span>であることから、<a class="morg-generated-anchor-ref" href="#a井001S井0000">1</a>から<a class="morg-generated-anchor-ref" href="#a井001S井0001">2</a>は<span class="morg-generated-katex">\(\simeq \)</span>の定義から自明である。</p><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井001S井0001">2</a>から<a class="morg-generated-anchor-ref" href="#a井001S井0002">3</a>は<a class="morg-generated-id" href="001V.html">[001V]</a>による。</p><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井001S井0002">3</a>から<a class="morg-generated-anchor-ref" href="#a井001S井0003">4</a>を示す。<a class="morg-generated-anchor-ref" href="#a井001S井0002">3</a>を仮定すると、<a class="morg-generated-id" href="001W.html">[001W]</a>から<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Retract}}}(\sum _{x:A}B(x),\sum _{x:A}a=x)\)</span>の要素を得る。すると、<a class="morg-generated-id" href="001N.html">[001N]</a>と<a class="morg-generated-id" href="001K.html">[001K]</a>より<span class="morg-generated-katex">\(\sum _{x:A}B(x)\)</span>は可縮である。</p><p class="morg-generated-paragraph">最後に<a class="morg-generated-anchor-ref" href="#a井001S井0003">4</a>から<a class="morg-generated-anchor-ref" href="#a井001S井0000">1</a>を示す。<a class="morg-generated-anchor-ref" href="#a井001S井0003">4</a>を仮定し、<span class="morg-generated-katex">\(x:A\)</span>と<span class="morg-generated-katex">\(y:B(x)\)</span>を仮定する。<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Fiber}}}(\lambda p.\mathord {\textnormal {\textsf {transport}}}(B,p,b),y)\)</span>が可縮であることを示す。<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Fiber}}}\)</span>の定義より、<span class="morg-generated-katex">\(\sum _{p:a=x}\mathord {\textnormal {\textsf {transport}}}(B,p,b)=y\)</span>が可縮であることを示せばよい。<a class="morg-generated-id" href="001X.html">[001X]</a>と<a class="morg-generated-id" href="001K.html">[001K]</a>から、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {pair}}}(a,b)=\mathord {\textnormal {\textsf {pair}}}(x,y)\)</span>が可縮であることを示せばよいが、これは仮定と<a class="morg-generated-id" href="001L.html">[001L]</a>から従う。</p></div></details></article><p class="morg-generated-paragraph">副産物として、対の同一視型の特徴付けは既に得られている。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="002B.html">[002B]</a> <span class="morg-generated-statement-header-header">系</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(c_{1},c_{2}:\sum _{x:A}B(x)\)</span>を要素とすると、同値
<center class="morg-generated-display"><span class="morg-generated-katex">\((c_{1}=c_{2})\simeq (\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\)</span></center>を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-id" href="001S.html">[001S]</a>と<a class="morg-generated-id" href="001X.html">[001X]</a>による。</p></div></details></article><p class="morg-generated-paragraph"><a class="morg-generated-id" href="001S.html">[001S]</a>を適用する際に便利な補題を用意する。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0024.html">[0024]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(a:A\)</span>を要素とする。<span class="morg-generated-katex">\(A\)</span>が可縮ならば<span class="morg-generated-katex">\((\sum _{x:A}B(x))\mathrel {\triangleleft \triangleright }B(a)\)</span>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(A\)</span>が可縮であると仮定する。<a class="morg-generated-id" href="001L.html">[001L]</a>より、関数<span class="morg-generated-katex">\(p:\prod _{x:A}x=a\)</span>を得る。関数<span class="morg-generated-katex">\(f:(\sum _{x:A}B(x))\to B(a)\)</span>を<span class="morg-generated-katex">\(\lambda z.\mathord {\textnormal {\textsf {transport}}}(B,p(\mathord {\textnormal {\textsf {proj}}}_{1}(z)),\mathord {\textnormal {\textsf {proj}}}_{2}(z))\)</span>と定義し、関数<span class="morg-generated-katex">\(g:B(a)\to (\sum _{x:A}B(x))\)</span>を<span class="morg-generated-katex">\(\lambda y.\mathord {\textnormal {\textsf {pair}}}(a,y)\)</span>と定義する。定義より、任意の<span class="morg-generated-katex">\(z:\sum _{x:A}B(x)\)</span>に対して、<span class="morg-generated-katex">\(p(\mathord {\textnormal {\textsf {proj}}}_{1}(z)):\mathord {\textnormal {\textsf {proj}}}_{1}(z)=\mathord {\textnormal {\textsf {proj}}}_{1}(g(f(z)))\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}:\mathord {\textnormal {\textsf {transport}}}(B,p(\mathord {\textnormal {\textsf {proj}}}_{1}(z)),\mathord {\textnormal {\textsf {proj}}}_{2}(z))=\mathord {\textnormal {\textsf {proj}}}_{2}(g(f(z)))\)</span>を得るので、<a class="morg-generated-id" href="001X.html">[001X]</a>より同一視<span class="morg-generated-katex">\(q:\prod _{z}g(f(z))=z\)</span>を得る。また、<a class="morg-generated-id" href="001L.html">[001L]</a>より同一視<span class="morg-generated-katex">\(r:p(a)=\mathord {\textnormal {\textsf {refl}}}\)</span>も得られるので、同一視<span class="morg-generated-katex">\(\lambda y.\mathord {\textnormal {\textsf {ap}}}(\lambda w.\mathord {\textnormal {\textsf {transport}}}(B,w,y),r):\prod _{y:B(a)}f(g(y))=y\)</span>を得る。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0025.html">[0025]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(C:\prod _{x:A}B(x)\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(a:A\)</span>と<span class="morg-generated-katex">\(b:B(a)\)</span>を要素とする。<span class="morg-generated-katex">\(\sum _{x:A}B(x)\)</span>が可縮ならば<span class="morg-generated-katex">\((\sum _{x:A}\sum _{y:B(x)}C(x,y))\mathrel {\triangleleft \triangleright }C(a,b)\)</span>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-id" href="0024.html">[0024]</a>からすぐに従う。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="002C.html">[002C]</a> <span class="morg-generated-statement-header-header">例</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(a_{1},a_{2}:\mathbf {1}\)</span>を要素とする。同値<span class="morg-generated-katex">\((a_{1}=a_{2})\simeq \mathbf {1}\)</span>を構成しよう。<a class="morg-generated-id" href="001S.html">[001S]</a>を適用する。<span class="morg-generated-katex">\(B:\mathbf {1}\to \mathcal {U}(0)\)</span>を<span class="morg-generated-katex">\(\lambda x.\mathbf {1}\)</span>と定義する。要素<span class="morg-generated-katex">\(\mathord {\star }:B(a_{1})\)</span>を得る。<a class="morg-generated-id" href="001O.html">[001O]</a>と<a class="morg-generated-id" href="0024.html">[0024]</a>により、<span class="morg-generated-katex">\(\sum _{x:\mathbf {1}}B(x)\)</span>は<span class="morg-generated-katex">\(B(a_{1})\)</span>のレトラクトである。再び<a class="morg-generated-id" href="001O.html">[001O]</a>により<span class="morg-generated-katex">\(B(a_{1})\)</span>は可縮なので、<a class="morg-generated-id" href="001K.html">[001K]</a>により<span class="morg-generated-katex">\(\sum _{x:\mathbf {1}}B(x)\)</span>は可縮である。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="002D.html">[002D]</a> <span class="morg-generated-statement-header-header">例</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(c_{1},c_{2}:A\times B\)</span>を要素とする。同値<span class="morg-generated-katex">\((c_{1}=c_{2})\simeq (\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2}))\times (\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\)</span>を構成しよう。<a class="morg-generated-id" href="001S.html">[001S]</a>を適用する。<span class="morg-generated-katex">\(E:A\times B\to \mathcal {U}(i)\)</span>を<span class="morg-generated-katex">\(\lambda z.(\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(z))\times (\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{2}(z))\)</span>と定義する。要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {pair}}}(\mathord {\textnormal {\textsf {refl}}},\mathord {\textnormal {\textsf {refl}}}):E(c_{1})\)</span>を得る。レトラクトの列
<center class="morg-generated-display"><span class="morg-generated-inline-ext"><span style="display: grid; grid-template-columns: max-content auto; grid-column-gap: 1em; text-align: start;"><span></span><span><span class="morg-generated-katex">\(\sum _{z:A\times B}E(z)\)</span></span><span><span class="morg-generated-katex">\(\triangleleft \)</span></span><span> {並び換え}</span><span></span><span><span class="morg-generated-katex">\(\sum _{x:A}\sum _{p:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=x}\sum _{y:B}\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})=y\)</span></span><span><span class="morg-generated-katex">\(\triangleleft \)</span></span><span> {<a class="morg-generated-id" href="001N.html">[001N]</a>と<a class="morg-generated-id" href="0025.html">[0025]</a>}</span><span></span><span><span class="morg-generated-katex">\(\sum _{y:B}\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1})=y\)</span></span></span></span></center>
を得て、最後の型は<a class="morg-generated-id" href="001N.html">[001N]</a>により可縮なので、<a class="morg-generated-id" href="001K.html">[001K]</a>より<span class="morg-generated-katex">\(\sum _{z:A\times B}E(z)\)</span>も可縮である。</p></div></div></article></div><nav class="morg-generated-section-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"></ul></div></nav></section></main><nav><ol class="morg-generated-d-pad"><li class="morg-generated-d-pad-previous"><a href="000S.html">←</a></li><li class="morg-generated-d-pad-up"><a href="0002.html">↑</a></li><li class="morg-generated-d-pad-next"><a href="000X.html">→</a></li></ol></nav></div></div></div></body></html>