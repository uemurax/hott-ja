<!DOCTYPE html>
<html><head prefix="og: https://ogp.me/ns#"><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width,initial-scale=1"></meta><title><span class="morg-generated-katex">\(n\)</span>型 -- ホモトピー型理論</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous"></link><meta property="og:title" content="\(n\)型"></meta><meta property="og:site_name" content="ホモトピー型理論"></meta><meta property="og:type" content="article"></meta><meta property="og:url" content="https://uemurax.github.io/003W.html"></meta><meta name="description" content="ホモトピー型理論についての文書"></meta><meta property="og:description" content="ホモトピー型理論についての文書"></meta><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded", function() {
  const elems = document.getElementsByClassName('morg-generated-katex');
  for(let i = 0; i < elems.length; i++) {
    renderMathInElement(elems[i], {
      delimiters: [
        {left: '\\(',
         right: '\\)',
         display: false}
      ]
    });
  }
});</script><link rel="stylesheet" href="default.css"></link><link rel="stylesheet" href="custom.css"></link></head><body><div id="morg-generated-default-body-container"><div id="morg-generated-default-header"><button id="morg-generated-default-side-button" onclick="morg_generated_default_toggle_side_nav();">☰</button><script>function morg_generated_default_toggle_side_nav() {
  console.log('called.');
  let e = document.getElementById('morg-generated-default-side-nav');
  console.log(e);
  if (e.style.display == "none") {
    e.style.display = "block";
  }
  else {
    e.style.display = "none";
  }
}</script><a class="morg-generated-default-site-title" href="index.html">ホモトピー型理論</a></div><nav id="morg-generated-default-side-nav" style="display: none;"><ol class="morg-generated-document-toc"><li class="morg-generated-document-front-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007H.html">貢献者</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li><li class="morg-generated-document-main-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0000.html">はじめに</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0077.html">型理論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0076.html">統一された正しい同一視の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0078.html">一価性公理とホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000R.html">識別子</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0001.html">型理論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0009.html">宇宙</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000A.html">関数型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000B.html">レコード型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000C.html">同一視型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002N.html">高次グルーポイド構造</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002T.html">自然数</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002U.html">有限余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0002.html">一価性公理</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000S.html">可縮性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001R.html">同一視型の基本定理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000X.html">一価性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001Y.html">関数外延性</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0021.html">一価性から関数外延性を導く</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0022.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000U.html">同値</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004I.html">他の同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary-selected"><a class="morg-generated-toc-edge-title" href="003W.html"><span class="morg-generated-katex">\(n\)</span>型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003Z.html">命題</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004N.html">同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004B.html">集合</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004Z.html">切り詰め</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0057.html">述語論理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005T.html">連結性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004V.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0003.html">高次帰納的型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0033.html">ファイバー余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0034.html">降下性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007Y.html">局所化</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0005.html">ホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0004.html">圏論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005B.html">圏</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005J.html">関手</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0065.html">自然変換</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="006D.html">前層</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></div></li><li class="morg-generated-document-back-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007E.html">参考文献</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007X.html">記法の一覧</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007F.html">索引</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li></ol></nav><div id="morg-generated-default-main-container"><div class="morg-generated-default-main-container"><nav><ol class="morg-generated-breadcrumb"><li class="morg-generated-breadcumrb-top"><a class="morg-generated-id" href="index.html">[index]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="003W.html">[003W]</a></li></ol></nav><main><section class="morg-generated-section"><h1 class="morg-generated-section-title"><a class="morg-generated-id" href="003W.html">[003W]</a> <span class="morg-generated-katex">\(n\)</span>型</h1><div class="morg-generated-section-body"><p class="morg-generated-paragraph"><a class="morg-generated-id" href="002N.html">[002N]</a>で型は高次グルーポイドの構造を持つと説明したが、その豊富な構造をすべて把握するのは容易ではない。<span class="morg-generated-katex">\(n\)</span>次元より上の構造が自明になっているような型は<em class="morg-generated-emph"><span class="morg-generated-katex">\(n\)</span>型</em>と呼ばれ、比較的解析が容易である。</p><p class="morg-generated-paragraph">次数<span class="morg-generated-katex">\(n\)</span>は<span class="morg-generated-katex">\(-2\)</span>から数えるのが都合がよい。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="003X.html">[003X]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>型<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {TruncLevel}}}:\mathcal {U}(0)\)</span>を<span class="morg-generated-katex">\(\mathbb {N}+(\mathbf {1}+\mathbf {1})\)</span>と定義する。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(-2:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {in}}}_{2}(\mathord {\textnormal {\textsf {in}}}_{2}(\mathord {\star }))\)</span>と定義する。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(-1:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {in}}}_{2}(\mathord {\textnormal {\textsf {in}}}_{1}(\mathord {\star }))\)</span>と定義する。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>に対して、要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n):\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(-2)\equiv -1\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(-1)\equiv \mathord {\textnormal {\textsf {in}}}_{1}(0)\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(\mathord {\textnormal {\textsf {in}}}_{1}(n))\equiv \mathord {\textnormal {\textsf {in}}}_{1}(\mathord {\textnormal {\textsf {succ}}}(n))\)</span>と定義する。</li></ul>
要素<span class="morg-generated-katex">\(n:\mathbb {N}\)</span>に対しては、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {in}}}_{1}\)</span>を省略して<span class="morg-generated-katex">\(n\)</span>自身を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>の要素とみなす。</p></div></div></article><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>は実質<span class="morg-generated-katex">\(\mathbb {N}\)</span>と同じであるが、<span class="morg-generated-katex">\(0\)</span>の代わりに<span class="morg-generated-katex">\(-2\)</span>から数えたものである。特に、次の<em class="morg-generated-emph">帰納法原理</em>を満たす:型の族<span class="morg-generated-katex">\(A:\mathord {\textnormal {\textsf {TruncLevel}}}\to \mathcal {U}(i)\)</span>に対して、関数<span class="morg-generated-katex">\(h:\prod _{x:\mathord {\textnormal {\textsf {TruncLevel}}}}A(x)\)</span>を構成するためには、
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(a:A(-2)\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(f:\prod _{x:\mathord {\textnormal {\textsf {TruncLevel}}}}A(x)\to A(\mathord {\textnormal {\textsf {succ}}}(x))\)</span></li></ul>
を構成すれば十分である。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="003Y.html">[003Y]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型とする。<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>に対して、型<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTrunc}}}(n,A):\mathcal {U}(i)\)</span>を次のように定義する。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTrunc}}}(-2,A)\equiv \mathord {\textnormal {\textsf {IsContr}}}(A)\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTrunc}}}(\mathord {\textnormal {\textsf {succ}}}(n),A)\equiv \prod _{x_{1},x_{2}:A}\mathord {\textnormal {\textsf {IsTrunc}}}(n,x_{1}=x_{2})\)</span></li></ul>
<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTrunc}}}(n,A)\)</span>の要素がある時、<span class="morg-generated-katex">\(A\)</span>は<dfn class="morg-generated-dfn"><span class="morg-generated-katex">\(n\)</span>型(<span class="morg-generated-katex">\(n\)</span>-type)</dfn>である、または<span class="morg-generated-katex">\(n\)</span>-truncatedであると言う。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0053.html">[0053]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。型<span class="morg-generated-katex">\(\mathord {\langle n\rangle \mathord {\textnormal {\textsf {-Type}}}}(i):\mathcal {U}(\mathord {\textnormal {\textsf {succ}}}(i))\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Record}}}\mathopen {\{ \negmedspace |}\mathord {\textnormal {\textsf {Type}}}:\mathcal {U}(i),\mathord {\textnormal {\textsf {is-trunc}}}:\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {Type}}})\mathclose {|\negmedspace \} }\)</span>と定義する。</p></div></div></article><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(-1\)</span>型は特別に<em class="morg-generated-emph">命題</em>と呼ばれ、<a class="morg-generated-id" href="003Z.html">[003Z]</a>でより詳しく調べる。<span class="morg-generated-katex">\(0\)</span>型は特別に<em class="morg-generated-emph">集合</em>と呼ばれ、<a class="morg-generated-id" href="004B.html">[004B]</a>でより詳しく調べる。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>型の一般的な性質をいくつか見る。まず、<span class="morg-generated-katex">\(n\)</span>型はレトラクトで閉じる(<a class="morg-generated-id" href="0045.html">[0045]</a>)。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0046.html">[0046]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(r:\mathord {\textnormal {\textsf {Retract}}}(A,B)\)</span>を要素、<span class="morg-generated-katex">\(a_{1},a_{2}:A\)</span>を要素とすると、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {Retract}}}(a_{1}=a_{2},r.\mathord {\textnormal {\textsf {section}}}(a_{1})=r.\mathord {\textnormal {\textsf {section}}}(a_{2}))\)</span>の要素を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(f\equiv r.\mathord {\textnormal {\textsf {section}}}\)</span>と<span class="morg-generated-katex">\(g\equiv r.\mathord {\textnormal {\textsf {retraction}}}\)</span>と<span class="morg-generated-katex">\(p\equiv r.\mathord {\textnormal {\textsf {r-s}}}\)</span>と定義する。<span class="morg-generated-katex">\(F:a_{1}=a_{2}\to f(a_{1})=f(a_{2})\)</span>を<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ap}}}(f)\)</span>と定義する。<span class="morg-generated-katex">\(G:f(a_{1})=f(a_{2})\to a_{1}=a_{2}\)</span>を<span class="morg-generated-katex">\(\lambda q.(p(a_{2})\circ \mathord {\textnormal {\textsf {ap}}}(g,q))\circ {(p(a_{1}))}^{-1}\)</span>と定義する。<span class="morg-generated-katex">\(\prod _{z:a_{1}=a_{2}}G(F(z))=z\)</span>を示すには、同一視型の帰納法により<span class="morg-generated-katex">\(G(F(\mathord {\textnormal {\textsf {refl}}}\lbrace a_{1}\rbrace ))=\mathord {\textnormal {\textsf {refl}}}\lbrace a_{1}\rbrace \)</span>を示せばよいが、<span class="morg-generated-katex">\(G(F(\mathord {\textnormal {\textsf {refl}}}\lbrace a_{1}\rbrace ))\equiv p(a_{1})\circ {(p(a_{1}))}^{-1}\)</span>なので<a class="morg-generated-id" href="0047.html">[0047]</a>を適用すればよい。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0045.html">[0045]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(r:\mathord {\textnormal {\textsf {Retract}}}(A,B)\)</span>と<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。<span class="morg-generated-katex">\(B\)</span>が<span class="morg-generated-katex">\(n\)</span>型ならば、<span class="morg-generated-katex">\(A\)</span>も<span class="morg-generated-katex">\(n\)</span>型である。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>についての帰納法による。<span class="morg-generated-katex">\(n\)</span>が<span class="morg-generated-katex">\(-2\)</span>の時は<a class="morg-generated-id" href="001K.html">[001K]</a>による。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>について主張が成り立つと仮定し、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>の場合を示す。<span class="morg-generated-katex">\(x_{1},x_{2}:A\)</span>に対して、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTrunc}}}(n,x_{1}=x_{2})\)</span>を示せばよいが、<a class="morg-generated-id" href="0046.html">[0046]</a>と帰納法の仮定から直ちに従う。</p></div></details></article><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>型はいくつかの型の構成で閉じる。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0048.html">[0048]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">関数外延性を仮定する。<span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。<span class="morg-generated-katex">\(\prod _{x:A}\mathord {\textnormal {\textsf {IsTrunc}}}(n,B(x))\)</span>の要素があるならば、<span class="morg-generated-katex">\(\prod _{x:A}B(x)\)</span>は<span class="morg-generated-katex">\(n\)</span>型である。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>についての帰納法による。<span class="morg-generated-katex">\(n\)</span>が<span class="morg-generated-katex">\(-2\)</span>の場合は<a class="morg-generated-id" href="0029.html">[0029]</a>による。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>の場合に主張が成り立つと仮定し、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>の場合を示す。<span class="morg-generated-katex">\(f:\prod _{x:A}B(x)\)</span>と<span class="morg-generated-katex">\(g:\prod _{x:A}B(x)\)</span>に対し、<span class="morg-generated-katex">\(f=g\)</span>が<span class="morg-generated-katex">\(n\)</span>型であることを示す。関数外延性より、同値<span class="morg-generated-katex">\((f=g)\simeq (\prod _{x:A}f(x)=g(x))\)</span>を得る。各<span class="morg-generated-katex">\(f(x)=g(x)\)</span>は<span class="morg-generated-katex">\(B\)</span>についての仮定より<span class="morg-generated-katex">\(n\)</span>型であるから、帰納法の仮定と<a class="morg-generated-id" href="0045.html">[0045]</a>から<span class="morg-generated-katex">\(f=g\)</span>は<span class="morg-generated-katex">\(n\)</span>型である。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="004X.html">[004X]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。<span class="morg-generated-katex">\(A\)</span>が<span class="morg-generated-katex">\(n\)</span>型で、任意の<span class="morg-generated-katex">\(x:A\)</span>に対して<span class="morg-generated-katex">\(B(x)\)</span>が<span class="morg-generated-katex">\(n\)</span>型ならば、<span class="morg-generated-katex">\(\sum _{x:A}B(x)\)</span>も<span class="morg-generated-katex">\(n\)</span>型である。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>についての帰納法による。<span class="morg-generated-katex">\(n\)</span>が<span class="morg-generated-katex">\(-2\)</span>の場合は容易である。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>の場合に主張が成り立つと仮定し、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>の場合を示す。<span class="morg-generated-katex">\(c_{1},c_{2}:\sum _{x:A}B(x)\)</span>に対し、<span class="morg-generated-katex">\(c_{1}=c_{2}\)</span>が<span class="morg-generated-katex">\(n\)</span>型であることを示す。<a class="morg-generated-id" href="002B.html">[002B]</a>より、同値
<center class="morg-generated-display"><span class="morg-generated-katex">\((c_{1}=c_{2})\simeq (\sum _{z:\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})}\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2}))\)</span></center>
を得る。仮定より、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {proj}}}_{1}(c_{1})=\mathord {\textnormal {\textsf {proj}}}_{1}(c_{2})\)</span>と各<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {transport}}}(B,z,\mathord {\textnormal {\textsf {proj}}}_{2}(c_{1}))=\mathord {\textnormal {\textsf {proj}}}_{2}(c_{2})\)</span>は<span class="morg-generated-katex">\(n\)</span>型である。よって、帰納法の仮定を適用すればよい。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="004F.html">[004F]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。<span class="morg-generated-katex">\(A\)</span>が<span class="morg-generated-katex">\(n\)</span>型ならば、<span class="morg-generated-katex">\(A\)</span>は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型である。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>についての帰納法による。<span class="morg-generated-katex">\(n\)</span>が<span class="morg-generated-katex">\(-2\)</span>の場合は<a class="morg-generated-id" href="001L.html">[001L]</a>による。</p><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(n\)</span>の場合に主張が成り立つと仮定して、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>の場合を示す。<span class="morg-generated-katex">\(A\)</span>が<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型と仮定して、任意の<span class="morg-generated-katex">\(x_{1},x_{2}:A\)</span>に対して<span class="morg-generated-katex">\(x_{1}=x_{2}\)</span>が<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型であることを示せばよいが、仮定と帰納法の過程から直ちに従う。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0052.html">[0052]</a> <span class="morg-generated-statement-header-header">系</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(a_{1},a_{2}:A\)</span>を要素、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。<span class="morg-generated-katex">\(A\)</span>が<span class="morg-generated-katex">\(n\)</span>型ならば、<span class="morg-generated-katex">\(a_{1}=a_{2}\)</span>も<span class="morg-generated-katex">\(n\)</span>型である。</p></div></div></article><p class="morg-generated-paragraph">相対的な<span class="morg-generated-katex">\(n\)</span>型の概念も導入する。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="005Q.html">[005Q]</a> <span class="morg-generated-statement-header-header">定義</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(f:A\to B\)</span>を関数、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。型<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTruncMap}}}(n,f):\mathcal {U}(i)\)</span>を<span class="morg-generated-katex">\(\prod _{y:B}\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {Fiber}}}(f,y))\)</span>と定義する。</p></div></div></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="005S.html">[005S]</a> <span class="morg-generated-statement-header-header">補題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(f:A\to B\)</span>を関数、<span class="morg-generated-katex">\(a:A\)</span>と<span class="morg-generated-katex">\(c:\mathord {\textnormal {\textsf {Fiber}}}(f,f(a))\)</span>を要素とすると、同値
<center class="morg-generated-display"><span class="morg-generated-katex">\((\mathord {\textnormal {\textsf {record}}}\mathopen {\{ \negmedspace |}\mathord {\textnormal {\textsf {elem}}}\equiv a,\mathord {\textnormal {\textsf {id}}}\equiv \mathord {\textnormal {\textsf {refl}}}\mathclose {|\negmedspace \} }=c)\simeq \mathord {\textnormal {\textsf {Fiber}}}(\mathord {\textnormal {\textsf {ap}}}(f)\lbrace \mathord {\textnormal {\textsf {proj}}}_{1}(c),a\rbrace ,\mathord {\textnormal {\textsf {proj}}}_{2}(c))\)</span></center>
を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-id" href="001S.html">[001S]</a>を適用する。レトラクト
<center class="morg-generated-display"><span class="morg-generated-inline-ext"><span style="display: grid; grid-template-columns: max-content auto; grid-column-gap: 1em; text-align: start;"><span></span><span><span class="morg-generated-katex">\(\sum _{z:\mathord {\textnormal {\textsf {Fiber}}}(f,f(a))}\mathord {\textnormal {\textsf {Fiber}}}(\mathord {\textnormal {\textsf {ap}}}(f)\lbrace \mathord {\textnormal {\textsf {proj}}}_{1}(c),a\rbrace ,\mathord {\textnormal {\textsf {proj}}}_{2}(c))\)</span></span><span><span class="morg-generated-katex">\(\triangleleft \)</span></span><span> {並び替え}</span><span></span><span><span class="morg-generated-katex">\(\sum _{x:A}\sum _{p:x=a}\sum _{q:f(x)=f(a)}f(p)=q\)</span></span><span><span class="morg-generated-katex">\(\triangleleft \)</span></span><span> {<a class="morg-generated-id" href="0026.html">[0026]</a>}</span><span></span><span><span class="morg-generated-katex">\(\sum _{q:f(a)=f(a)}f(\mathord {\textnormal {\textsf {refl}}})=q\)</span></span></span></span></center>
を得て、最後の型は<a class="morg-generated-id" href="001N.html">[001N]</a>より可縮である。</p></div></details></article><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="005R.html">[005R]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A,B:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(f:A\to B\)</span>を関数とする。
<ol class="morg-generated-ordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井005R井0000">1</a></span>型<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTruncMap}}}(-2,f)\)</span>と<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsEquiv}}}(f)\)</span>は論理的に同値である。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井005R井0001">2</a></span>要素<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>に対して、次の型は論理的に同値である。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTruncMap}}}(\mathord {\textnormal {\textsf {succ}}}(n),f)\)</span></li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(\prod _{x_{1},x_{2}:A}\mathord {\textnormal {\textsf {IsTruncMap}}}(n,\mathord {\textnormal {\textsf {ap}}}(f)\lbrace x_{1},x_{2}\rbrace )\)</span></li></ul></li></ol></p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井005R井0000">1</a>は定義から自明である。</p><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井005R井0001">2</a>は次のように分かる。
<center class="morg-generated-display"><span class="morg-generated-inline-ext"><span style="display: grid; grid-template-columns: max-content auto; grid-column-gap: 1em; text-align: start;"><span></span><span><span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {IsTruncMap}}}(\mathord {\textnormal {\textsf {succ}}}(n),f)\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {定義}</span><span></span><span><span class="morg-generated-katex">\(\prod _{y:B}\prod _{z_{1},z_{2}:\mathord {\textnormal {\textsf {Fiber}}}(f,y)}\mathord {\textnormal {\textsf {IsTrunc}}}(n,z_{1}=z_{2})\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {並び替え}</span><span></span><span><span class="morg-generated-katex">\(\prod _{x_{1}:A}\prod _{y:B}\prod _{p_{1}:f(x_{1})=y}\prod _{z_{2}:\mathord {\textnormal {\textsf {Fiber}}}(f,y)}\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {record}}}\mathopen {\{ \negmedspace |}\mathord {\textnormal {\textsf {elem}}}\equiv x_{1},\mathord {\textnormal {\textsf {id}}}\equiv p_{1}\mathclose {|\negmedspace \} }=z_{2})\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {<span class="morg-generated-katex">\(p_{1}\)</span>についての帰納法}</span><span></span><span><span class="morg-generated-katex">\(\prod _{x_{1}:A}\prod _{z_{2}:\mathord {\textnormal {\textsf {Fiber}}}(f,f(x_{1}))}\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {record}}}\mathopen {\{ \negmedspace |}\mathord {\textnormal {\textsf {elem}}}\equiv x_{1},\mathord {\textnormal {\textsf {id}}}\equiv \mathord {\textnormal {\textsf {refl}}}\mathclose {|\negmedspace \} }=z_{2})\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {<a class="morg-generated-id" href="005S.html">[005S]</a>}</span><span></span><span><span class="morg-generated-katex">\(\prod _{x_{1}:A}\prod _{z_{2}:\mathord {\textnormal {\textsf {Fiber}}}(f,f(x_{1}))}\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {Fiber}}}(\mathord {\textnormal {\textsf {ap}}}(f),\mathord {\textnormal {\textsf {proj}}}_{2}(z_{2})))\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {並び替え}</span><span></span><span><span class="morg-generated-katex">\(\prod _{x_{2},x_{1}:A}\prod _{p:f(x_{2})=f(x_{1})}\mathord {\textnormal {\textsf {IsTrunc}}}(n,\mathord {\textnormal {\textsf {Fiber}}}(\mathord {\textnormal {\textsf {ap}}}(f),p))\)</span></span><span><span class="morg-generated-katex">\(\leftrightarrow \)</span></span><span> {定義}</span><span></span><span><span class="morg-generated-katex">\(\prod _{x_{2},x_{1}:A}\mathord {\textnormal {\textsf {IsTruncMap}}}(n,\mathord {\textnormal {\textsf {ap}}}(f)\lbrace x_{2},x_{1}\rbrace )\)</span></span></span></span></center></p></div></details></article></div><nav class="morg-generated-section-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003Z.html">命題</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004N.html">同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004B.html">集合</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004Z.html">切り詰め</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0057.html">述語論理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005T.html">連結性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004V.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></nav></section></main><nav><ol class="morg-generated-d-pad"><li class="morg-generated-d-pad-previous"><a href="0002.html">←</a></li><li class="morg-generated-d-pad-up"><a href="index.html">↑</a></li><li class="morg-generated-d-pad-next"><a href="0003.html">→</a></li></ol></nav></div></div></div></body></html>