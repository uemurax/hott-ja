<!DOCTYPE html>
<html><head prefix="og: https://ogp.me/ns#"><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width,initial-scale=1"></meta><title>切り詰め -- ホモトピー型理論</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous"></link><meta property="og:title" content="切り詰め"></meta><meta property="og:site_name" content="ホモトピー型理論"></meta><meta property="og:type" content="article"></meta><meta property="og:url" content="https://uemurax.github.io/004Z.html"></meta><meta name="description" content="ホモトピー型理論についての文書"></meta><meta property="og:description" content="ホモトピー型理論についての文書"></meta><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script><script>document.addEventListener("DOMContentLoaded", function() {
  const elems = document.getElementsByClassName('morg-generated-katex');
  for(let i = 0; i < elems.length; i++) {
    renderMathInElement(elems[i], {
      delimiters: [
        {left: '\\(',
         right: '\\)',
         display: false}
      ]
    });
  }
});</script><link rel="stylesheet" href="default.css"></link><link rel="stylesheet" href="custom.css"></link></head><body><div id="morg-generated-default-body-container"><div id="morg-generated-default-header"><button id="morg-generated-default-side-button" onclick="morg_generated_default_toggle_side_nav();">☰</button><script>function morg_generated_default_toggle_side_nav() {
  console.log('called.');
  let e = document.getElementById('morg-generated-default-side-nav');
  console.log(e);
  if (e.style.display == "none") {
    e.style.display = "block";
  }
  else {
    e.style.display = "none";
  }
}</script><a class="morg-generated-default-site-title" href="index.html">ホモトピー型理論</a></div><nav id="morg-generated-default-side-nav" style="display: none;"><ol class="morg-generated-document-toc"><li class="morg-generated-document-front-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007H.html">貢献者</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li><li class="morg-generated-document-main-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0000.html">はじめに</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0077.html">型理論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0076.html">統一された正しい同一視の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0078.html">一価性公理とホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000R.html">識別子</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0001.html">型理論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0009.html">宇宙</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000A.html">関数型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000B.html">レコード型</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000C.html">同一視型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002N.html">高次グルーポイド構造</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002T.html">自然数</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="002U.html">有限余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0002.html">一価性公理</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000S.html">可縮性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001R.html">同一視型の基本定理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000X.html">一価性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="001Y.html">関数外延性</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0021.html">一価性から関数外延性を導く</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0022.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="000U.html">同値</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004I.html">他の同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details" open="true"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003W.html"><span class="morg-generated-katex">\(n\)</span>型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="003Z.html">命題</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004N.html">同値の概念</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004B.html">集合</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary-selected"><a class="morg-generated-toc-edge-title" href="004Z.html">切り詰め</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0057.html">述語論理</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005T.html">連結性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="004V.html">構造同一原理</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0003.html">高次帰納的型</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0033.html">ファイバー余積</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0034.html">降下性</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007Y.html">局所化</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0005.html">ホモトピー論</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0004.html">圏論</a></summary><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005B.html">圏</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="005J.html">関手</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="0065.html">自然変換</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="006D.html">前層</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></details></li></ul></div></li><li class="morg-generated-document-back-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007E.html">参考文献</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007X.html">記法の一覧</a></summary><ul class="morg-generated-toc-node"></ul></details></li><li class="morg-generated-toc-edge"><details class="morg-generated-toc-edge-details"><summary class="morg-generated-toc-edge-summary"><a class="morg-generated-toc-edge-title" href="007F.html">索引</a></summary><ul class="morg-generated-toc-node"></ul></details></li></ul></div></li></ol></nav><div id="morg-generated-default-main-container"><div class="morg-generated-default-main-container"><nav><ol class="morg-generated-breadcrumb"><li class="morg-generated-breadcumrb-top"><a class="morg-generated-id" href="index.html">[index]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="003W.html">[003W]</a></li><li class="morg-generated-breadcrumb-node"><a class="morg-generated-id" href="004Z.html">[004Z]</a></li></ol></nav><main><section class="morg-generated-section"><h1 class="morg-generated-section-title"><a class="morg-generated-id" href="004Z.html">[004Z]</a> 切り詰め</h1><div class="morg-generated-section-body"><p class="morg-generated-paragraph">型は∞グルーポイドという高次元の構造を持つのであったが、その豊富な構造ゆえ型を解析するのは必ずしも容易ではない。高次元の構造を解析する常套手段はより低次元の構造で近似することである。型の<span class="morg-generated-katex">\(n\)</span>型による最良の近似を導入する。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0050.html">[0050]</a> <span class="morg-generated-statement-header-header">規則</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。
<ul class="morg-generated-unordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><dfn class="morg-generated-dfn"><span class="morg-generated-katex">\(n\)</span>切り詰め(<span class="morg-generated-katex">\(n\)</span>-truncation)</dfn><span class="morg-generated-katex">\({\| A\| }_{n}:\mathcal {U}(i)\)</span>を構成できる。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\({\| A\| }_{n}\)</span>は<span class="morg-generated-katex">\(n\)</span>型である(ことを示す要素を構成できる)。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span>要素<span class="morg-generated-katex">\(a:A\)</span>に対して、要素<span class="morg-generated-katex">\({|a|}_{n}:{\| A\| }_{n}\)</span>を構成できる。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(c:{\| A\| }_{n}\)</span>を要素、<span class="morg-generated-katex">\(j\)</span>を階数、<span class="morg-generated-katex">\(B:{\| A\| }_{n}\to \mathcal {U}(j)\)</span>を型の族、<span class="morg-generated-katex">\(f:\prod _{x:A}B({|x|}_{n})\)</span>を関数とする。<span class="morg-generated-katex">\(\prod _{z:{\| A\| }_{n}}\mathord {\textnormal {\textsf {IsTrunc}}}(n,B(z))\)</span>の要素があるなら、要素<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{{\| A\| }_{n}}(c,B,f):B(c)\)</span>を構成できる。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head">-</span><span class="morg-generated-katex">\(a:A\)</span>を要素、<span class="morg-generated-katex">\(j\)</span>を階数、<span class="morg-generated-katex">\(B:{\| A\| }_{n}\to \mathcal {U}(j)\)</span>を型の族、<span class="morg-generated-katex">\(f:\prod _{x:A}B({|x|}_{n})\)</span>を関数とする。<span class="morg-generated-katex">\(\prod _{z:{\| A\| }_{n}}\mathord {\textnormal {\textsf {IsTrunc}}}(n,B(z))\)</span>の要素があるなら、<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {ind}}}_{{\| A\| }_{n}}(a,B,f)\equiv f(a)\)</span>を定義される。</li></ul></p></div></div></article><p class="morg-generated-paragraph"><a class="morg-generated-id" href="0050.html">[0050]</a>は帰納的型の規則と類似している。実際、<span class="morg-generated-katex">\({\| A\| }_{n}\)</span>を高次帰納的型(<a class="morg-generated-id" href="0003.html">[0003]</a>)の一種と捉えることもできる。<span class="morg-generated-katex">\(\lambda a.{|a|}_{n}\)</span>は構成子である。それより下の規則は<em class="morg-generated-emph">帰納法原理</em>を表すが、帰納法が使える状況は<span class="morg-generated-katex">\(B\)</span>が<span class="morg-generated-katex">\(n\)</span>型の族である場合に制限されている。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0051.html">[0051]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。次は論理的に同値である。
<ol class="morg-generated-ordered-list" style="list-style-type: none;"><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井0051井0000">1</a></span><span class="morg-generated-katex">\(A\)</span>は<span class="morg-generated-katex">\(n\)</span>型である。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井0051井0001">2</a></span>関数<span class="morg-generated-katex">\(\lambda x.{|x|}_{n}:A\to {\| A\| }_{n}\)</span>は同値である。</li><li class="morg-generated-list-item"><span class="morg-generated-list-item-head"><a class="morg-generated-anchor" id="a井0051井0002">3</a></span><span class="morg-generated-katex">\(A\)</span>は<span class="morg-generated-katex">\({\| A\| }_{n}\)</span>のレトラクトである。</li></ol></p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井0051井0001">2</a>から<a class="morg-generated-anchor-ref" href="#a井0051井0002">3</a>は自明である。<a class="morg-generated-anchor-ref" href="#a井0051井0002">3</a>から<a class="morg-generated-anchor-ref" href="#a井0051井0000">1</a>は<a class="morg-generated-id" href="0045.html">[0045]</a>による。</p><p class="morg-generated-paragraph"><a class="morg-generated-anchor-ref" href="#a井0051井0000">1</a>から<a class="morg-generated-anchor-ref" href="#a井0051井0001">2</a>を示す。<span class="morg-generated-katex">\(A\)</span>が<span class="morg-generated-katex">\(n\)</span>型なので、帰納法より関数<span class="morg-generated-katex">\(g:{\| A\| }_{n}\to A\)</span>であって任意の<span class="morg-generated-katex">\(a:A\)</span>に対して<span class="morg-generated-katex">\(g({|a|}_{n})\equiv a\)</span>となるものを構成できる。特に、<span class="morg-generated-katex">\(g\circ (\lambda x.{|x|}_{n})\sim \mathord {\textnormal {\textsf {id}}}\)</span>である。<span class="morg-generated-katex">\((\lambda x.{|x|}_{n})\circ g\sim \mathord {\textnormal {\textsf {id}}}\)</span>を示す。各<span class="morg-generated-katex">\(z:{\| A\| }_{n}\)</span>に対して<span class="morg-generated-katex">\({|g(z)|}_{n}=z\)</span>は<a class="morg-generated-id" href="0052.html">[0052]</a>より<span class="morg-generated-katex">\(n\)</span>型なので、帰納法により<span class="morg-generated-katex">\(\prod _{x:A}{|g({|x|}_{n})|}_{n}={|x|}_{n}\)</span>を示せばよいがこれは定義から明らかである。</p></div></details></article><p class="morg-generated-paragraph"><span class="morg-generated-katex">\({\| A\| }_{n}\)</span>の性質を調べる際には一価性が不可欠である。一価性をどう使うかは次の<a class="morg-generated-id" href="0056.html">[0056]</a>にまとめられる。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0056.html">[0056]</a> <span class="morg-generated-statement-header-header">定理</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">一価性と関数外延性を仮定する。<span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(B:A\to \mathcal {U}(i)\)</span>を型の族、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とする。任意の<span class="morg-generated-katex">\(x:A\)</span>に対して<span class="morg-generated-katex">\(B(x)\)</span>は<span class="morg-generated-katex">\(n\)</span>型であると仮定する。<a class="morg-generated-id" href="0054.html">[0054]</a>より、帰納法で型の族<span class="morg-generated-katex">\(T:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\to \mathcal {U}(i)\)</span>であって、任意の<span class="morg-generated-katex">\(u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>に対して<span class="morg-generated-katex">\(T(u)\)</span>は<span class="morg-generated-katex">\(n\)</span>型であり、任意の<span class="morg-generated-katex">\(x:A\)</span>に対して<span class="morg-generated-katex">\(T({|x|}_{\mathord {\textnormal {\textsf {succ}}}(n)})\equiv B(x)\)</span>であるものを構成できる。<a class="morg-generated-id" href="004X.html">[004X]</a>と<a class="morg-generated-id" href="004F.html">[004F]</a>より<span class="morg-generated-katex">\(\sum _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u)\)</span>は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型なので、関数<span class="morg-generated-katex">\(\lambda z.\mathord {\textnormal {\textsf {pair}}}({|\mathord {\textnormal {\textsf {proj}}}_{1}(z)|}_{\mathord {\textnormal {\textsf {succ}}}(n)},\mathord {\textnormal {\textsf {proj}}}_{2}(z)):(\sum _{x:A}B(x))\to (\sum _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u))\)</span>は関数
<center class="morg-generated-display"><span class="morg-generated-katex">\(H:{\| \sum _{x:A}B(x)\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\to (\sum _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u))\)</span></center>
を誘導する。この時、関数<span class="morg-generated-katex">\(H\)</span>は同値である。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><span class="morg-generated-katex">\(\sum _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u)\)</span>が<span class="morg-generated-katex">\({\| \sum _{x:A}B(x)\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>と同じ帰納法原理を満たすことを見る。<span class="morg-generated-katex">\(C:(\sum _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u))\to \mathcal {U}(i)\)</span>を型の族とし、各<span class="morg-generated-katex">\(C(u)\)</span>は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型であると仮定する。<span class="morg-generated-katex">\(f:\prod _{z:\sum _{x:A}B(x)}C(\mathord {\textnormal {\textsf {pair}}}({|z|}_{\mathord {\textnormal {\textsf {succ}}}(n)},\mathord {\textnormal {\textsf {proj}}}_{2}(z)))\)</span>を関数とする。<span class="morg-generated-katex">\(D:\prod _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}T(u)\to \mathcal {U}(i)\)</span>を<span class="morg-generated-katex">\(C\)</span>のカリー化、<span class="morg-generated-katex">\(g:\prod _{x:A}\prod _{y:B(x)}D({|x|}_{\mathord {\textnormal {\textsf {succ}}}(n)},y)\)</span>を<span class="morg-generated-katex">\(f\)</span>のカリー化とする。<a class="morg-generated-id" href="0048.html">[0048]</a>より各<span class="morg-generated-katex">\(\prod _{v:T(u)}D(u,v)\)</span>は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型なので、帰納法で関数<span class="morg-generated-katex">\(h:\prod _{u:{\| A\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}}\prod _{v:T(u)}D(u,v)\)</span>を得る。<span class="morg-generated-katex">\(h\)</span>を逆カリー化すればよい。</p></div></details></article><p class="morg-generated-paragraph"><a class="morg-generated-id" href="0056.html">[0056]</a>を使う例として、<span class="morg-generated-katex">\({\| A\| }_{n}\)</span>の同一視型の特徴付けを与える。<span class="morg-generated-katex">\(n\)</span>が<span class="morg-generated-katex">\(-2\)</span>の場合は自明なので、興味があるのはそれ以外の場合である。</p><article class="morg-generated-article"><div class="morg-generated-statement"><header class="morg-generated-statement-header"><a class="morg-generated-id" href="0055.html">[0055]</a> <span class="morg-generated-statement-header-header">命題</span></header><div class="morg-generated-statement-body"><p class="morg-generated-paragraph">一価性と関数外延性を仮定する。<span class="morg-generated-katex">\(i\)</span>を階数、<span class="morg-generated-katex">\(A:\mathcal {U}(i)\)</span>を型、<span class="morg-generated-katex">\(a_{1},a_{2}:A\)</span>を要素、<span class="morg-generated-katex">\(n:\mathord {\textnormal {\textsf {TruncLevel}}}\)</span>を要素とすると、同値<span class="morg-generated-katex">\(({|a_{1}|}_{\mathord {\textnormal {\textsf {succ}}}(n)}={|a_{2}|}_{\mathord {\textnormal {\textsf {succ}}}(n)})\simeq {\| a_{1}=a_{2}\| }_{n}\)</span>を構成できる。</p></div></div><details class="morg-generated-proof"><summary class="morg-generated-proof-header">証明</summary><div class="morg-generated-proof-body"><p class="morg-generated-paragraph"><a class="morg-generated-id" href="0056.html">[0056]</a>を型の族<span class="morg-generated-katex">\(\lambda x.{\| a_{1}=x\| }_{n}:A\to \mathcal {U}(i)\)</span>に適用すると、<a class="morg-generated-id" href="001S.html">[001S]</a>より、<span class="morg-generated-katex">\({\| \sum _{x:A}{\| a_{1}=x\| }_{n}\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>が可縮であることを示せば十分である。要素<span class="morg-generated-katex">\(c_{1}:{\| \sum _{x:A}{\| a_{1}=x\| }_{n}\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>を<span class="morg-generated-katex">\({|\mathord {\textnormal {\textsf {pair}}}(a_{1},{|\mathord {\textnormal {\textsf {refl}}}|}_{n})|}_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>と定義する。任意の<span class="morg-generated-katex">\(w:{\| \sum _{x:A}{\| a_{1}=x\| }_{n}\| }_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>に対して同一視<span class="morg-generated-katex">\(c_{1}=w\)</span>を構成する。<a class="morg-generated-id" href="0052.html">[0052]</a>よりこの同一視型は<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {succ}}}(n)\)</span>型なので、帰納法より任意の<span class="morg-generated-katex">\(x:A\)</span>と<span class="morg-generated-katex">\(v:{\| a_{1}=x\| }_{n}\)</span>に対して同一視<span class="morg-generated-katex">\(c_{1}={|\mathord {\textnormal {\textsf {pair}}}(x,v)|}_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>を構成すればよい。この同一視型は定義から<span class="morg-generated-katex">\(n\)</span>型なので、帰納法より任意の<span class="morg-generated-katex">\(x:A\)</span>と<span class="morg-generated-katex">\(y:a_{1}=x\)</span>に対して同一視<span class="morg-generated-katex">\(c_{1}={|\mathord {\textnormal {\textsf {pair}}}(x,{|y|}_{n})|}_{\mathord {\textnormal {\textsf {succ}}}(n)}\)</span>を構成すればよいが、同一視型の帰納法で<span class="morg-generated-katex">\(\mathord {\textnormal {\textsf {refl}}}\)</span>を与えればよい。</p></div></details></article></div><nav class="morg-generated-section-toc"><div class="morg-generated-toc"><ul class="morg-generated-toc-node"></ul></div></nav></section></main><nav><ol class="morg-generated-d-pad"><li class="morg-generated-d-pad-previous"><a href="004B.html">←</a></li><li class="morg-generated-d-pad-up"><a href="003W.html">↑</a></li><li class="morg-generated-d-pad-next"><a href="0057.html">→</a></li></ol></nav></div></div></div></body></html>