\documentclass[index]{subfiles}

\begin{document}

\mySection{001Y}{関数外延性}

関数\myInlineMath{f, g \myElemOf \myDFunType{x \myElemOf A}{B\myAppParen{x}}}
の「自然な」同一視のしかたは任意の\myInlineMath{x \myElemOf A}に対して
\myInlineMath{f\myAppParen{x}}と\myInlineMath{g\myAppParen{x}}を
同一視することである。
つまり、同値
\myInlineMath{(f \myIdType g) \myEquiv
  \myDFunType{x \myElemOf A}{f\myAppParen{x} \myIdType g\myAppParen{x}}}
が期待される。
しかし、関数\myInlineMath{(\myDFunType{x \myElemOf A}
  {f\myAppParen{x} \myIdType g\myAppParen{x}}) \myFunType
  (f \myIdType g)}
は関数型の規則と同一視型の規則からは構成できないことが知られている\myCiteParen{streicher1993investigations}。
そのため、この同値を得るためには何らかの公理が必要である。

\subfile{node-001Z-function-extensionality}

要素\myInlineMath{\myAbs{x}{\myRefl{f\myAppParen{x}}}
  \myElemOf \myDFunType{x \myElemOf A}
  {f\myAppParen{x} \myIdType f\myAppParen{x}}}があるので
\myRef{001S}を適用できて、
\myInlineMath{\myDFunType{x \myElemOf A}{B\myAppParen{x}}}が関数外延性を持つ時、
任意の関数\myInlineMath{f, g \myElemOf \myDFunType{x \myElemOf A}{B\myAppParen{x}}}
に対して同値\myInlineMath{(f \myIdType g) \myEquiv
  \myDFunType{x \myElemOf A}{f\myAppParen{x} \myIdType g\myAppParen{x}}}を得る。

\subfile{node-0020-funext-axiom}
\subfile{node-0029-funext-alt}

\begin{mySubsections}
  \subfile{node-0021-univalence-implies-funext}
\end{mySubsections}

\end{document}
